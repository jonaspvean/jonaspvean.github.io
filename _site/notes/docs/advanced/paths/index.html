<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p>Paths are pretty complex to reason about because, especially for a static site generator, they can come from so many places.</p>

<p>A full file path to a piece of content? Also a path. What about a slug for a piece of content? Yet another path.</p>

<p>It would be silly to type these all as <code class="language-plaintext highlighter-rouge">string</code> and call it a day as it’s pretty common to accidentally mistake one type of path for another. Unfortunately, TypeScript does not have <a href="https://en.wikipedia.org/wiki/Nominal_type_system" rel="external nofollow noopener" target="_blank">nominal types</a> for type aliases meaning even if you made custom types of a server-side slug or a client-slug slug, you can still accidentally assign one to another and TypeScript wouldn’t catch it.</p>

<p>Luckily, we can mimic nominal typing using <a href="https://www.typescriptlang.org/play#example/nominal-typing" rel="external nofollow noopener" target="_blank">brands</a>.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// instead of</span>
<span class="kd">type</span> <span class="nx">FullSlug</span> <span class="o">=</span> <span class="kr">string</span>

<span class="c1">// we do</span>
<span class="kd">type</span> <span class="nx">FullSlug</span> <span class="o">=</span> <span class="kr">string</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="na">__brand</span><span class="p">:</span> <span class="dl">"</span><span class="s2">full</span><span class="dl">"</span> <span class="p">}</span>

<span class="c1">// that way, the following will fail typechecking</span>
<span class="kd">const</span> <span class="nx">slug</span><span class="p">:</span> <span class="nx">FullSlug</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">some random string</span><span class="dl">"</span>
</code></pre></div></div>

<p>While this prevents most typing mistakes <em>within</em> our nominal typing system (e.g. mistaking a server slug for a client slug), it doesn’t prevent us from <em>accidentally</em> mistaking a string for a client slug when we forcibly cast it.</p>

<p>Thus, we still need to be careful when casting from a string to one of these nominal types in the ‘entrypoints’, illustrated with hexagon shapes in the diagram below.</p>

<p>The following diagram draws the relationships between all the path sources, nominal path types, and what functions in <code class="language-plaintext highlighter-rouge">quartz/path.ts</code> convert between them.</p>

<pre><code class="language-mermaid">graph LR
    Browser --&gt; Window &amp; LinkElement
    Window --"getFullSlug()"--&gt; FullSlug[Full Slug]
    LinkElement --".href"--&gt; Relative[Relative URL]
    FullSlug --"simplifySlug()" --&gt; SimpleSlug[Simple Slug]
    SimpleSlug --"pathToRoot()"--&gt; Relative
    SimpleSlug --"resolveRelative()" --&gt; Relative
    MD --&gt; FilePath &amp; Links[Markdown links]
    Links --"transformLink()"--&gt; Relative
    FilePath --"slugifyFilePath()"--&gt; FullSlug[Full Slug]
    style FullSlug stroke-width:4px
</code></pre>

<p>Here are the main types of slugs with a rough description of each type of path:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">FilePath</code>: a real file path to a file on disk. Cannot be relative and must have a file extension.</li>
  <li>
<code class="language-plaintext highlighter-rouge">FullSlug</code>: cannot be relative and may not have leading or trailing slashes. It can have <code class="language-plaintext highlighter-rouge">index</code> as it’s last segment. Use this wherever possible is it’s the most ‘general’ interpretation of a slug.</li>
  <li>
<code class="language-plaintext highlighter-rouge">SimpleSlug</code>: cannot be relative and shouldn’t have <code class="language-plaintext highlighter-rouge">/index</code> as an ending or a file extension. It <em>can</em> however have a trailing slash to indicate a folder path.</li>
  <li>
<code class="language-plaintext highlighter-rouge">RelativeURL</code>: must start with <code class="language-plaintext highlighter-rouge">.</code> or <code class="language-plaintext highlighter-rouge">..</code> to indicate it’s a relative URL. Shouldn’t have <code class="language-plaintext highlighter-rouge">/index</code> as an ending or a file extension but can contain a trailing slash.</li>
</ul>

<p>To get a clearer picture of how these relate to each other, take a look at the path tests in <code class="language-plaintext highlighter-rouge">quartz/path.test.ts</code>.</p>
</body></html>
